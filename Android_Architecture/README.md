# Summary-아키텍처를 알아야 앱 개발이 보인다

## CHAPTER 01 안드로이드 애플리케이션 설계

### 1. 애플리케이션 설계란?
- 애플리케이션은 구현 후 변경하는데 비용이 많이 든다
- 잘 설계된 애플리케이션은 비 비용을 줄여주고 성능, 보안, 안정성 등의 측면에서 많은 이점이 있음

### 2. 애플리케이션 설계 원칙
- 단일 책임 원칙(Single Responsibility Principle)
  + 모든 클래스는 하나의 책임만 가짐
  + 그 책임을 완전히 캡슐화해야 함을 일컫는다

- 개방-폐쇄 원칙 (Open Closed Principle)
  + 확장에 대해서는 열려 있어야 하고 수정에 대해서는 닫혀 있어야 함

- 리스코프 치환 원칙 (Liskov Substitution Principle)
  + 클래스 S가 클래스 T의 자식 클래스라면 별다른 변경없이 부모 클래스 T를 자식 클래스 S로 치환할 수 있어야 한다는 원칙
  + 다운 캐스팅 된 인스턴스가 논리적으로 그 역할이 문제없어야 함

- 인터페이스 분리 원칙 (Interface Segregation Principle)
  + 어떠한 클래스가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙
  + 추상 클래스로 fly(), cry() 있다고 가정했을 떄 펭귄이 나오면 fly() 를 구현못한다 -> Flyable 인터페이스를 통해 날 수 있는 새

- 의존성 역전 원칙 (Dependency Inversion Principle)
  + 모듈들을 분리하는 특정 형식을 지칭
  + 이 원칙에 따르면, 상위 계층이 하위 계층에 의존하는 전통적이 ㄴ의존 관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립
    * 상위 모듈은 하위 모듈에 의존해선 안 됨
    * 추상화는 세부 사항에 의존해서는 안 됨
  + 안드로이드 기기가 전용 충전기를 추상화 시켜서 의존했지만 현재는 USB-C 타입이라는 인터페이스에 의존하게 됨

### 3. 클린 아키텍처
- 소프트웨어의 관심사를 계층별로 분리하는 소프트웨어 디자인 철학 
- Entities - (엔터프라이즈 비즈니스 룰) - Use Cases - (애플리케이션 비즈니스 룰) - Presenters - (인터페이스 어댑터) - UI - (Frameworks & Drivers)
- 종속성이 외부로부터 내부로 의존

- Entities
  + 전사적 비즈니스 규칙을 캡슐화
  + 데이터 구조 or 메서드를 포함하는 객체, POJO 클래스
  + 순수한 자바 또는 코틀린 코드일 떄 유닛 테스트 수월

- Use Cases
  + 애플리케이션 관련된 비즈니스 규칙을 포함하고 시스템의 모든 유스 케이스 규현체들을 캡슐화
  + 안드로이드의 경우 Model, Repository, Executor 등이 이 계측에 속함
    * Model - DB질의 또는 네트워크 요청 등의 비즈니스 로직 수행
    * Repository - DB 접근하거나 저장 또는 원격 서버의 데이터를 요청하는 역할, 인터페이스를 구현하여 외부 계층의 연결을 느슨하게 함
    * Executor - Repository or Model 과 관련된 자겅비 백그라운드에서 작업 수행할 수 있도록 작업 스레드를 관리하고 제공

- Interface Adapters
  + UseCase or Entity 로부터 얻은 데이터를 가공하는 계층하여 UI에 전달
  + Presenter, View, ViewModel, Controller
  + 비즈니스 로직과 프레임워크 코드를 연결하는 역할

- Frameworks & Drivers
  + 가장 바깥쪽 계층으로 일반적으로 UI 및 액티비티 프로그래먼트 인텐트 전달 그리고 DB 등 네트워크 및 프레임워크 코드

### 4. 안드로이드 특징
- 안드로이드는 진입점이 다양함
- 메모리 부족과 같은 시스템 조건으로 종료될 수 있음

### 5. 안드로이드 애플리케이션 설계 원칙
- Activity 와 Fragment 클래스 의존성은 최소화하는 것이 좋음
- 관심사 분리하는 것은 클래스ㅇ 간의 강한 의존성을 느슨하게 하면서 모듈화시킴

### 6. 권장하는 애플리케이션 설계
- Activity - ViewModel - Repository - Model or Remote Data Sources
- 각 순서별로 참조하되 참조하는 하위 계층의 의존성이 어떻게 변경되든 상위 계층은 관심이 없어야 한다

### 7. 안드로이드 애플리케이션 설계 패턴
- MVC, MVP, MVVM 디자인 패턴이 있음

- MVC 디자인 패턴
  + model, view, controller 세 가지 주요 측면으로 관심사 분리 
  + 자바 서버 스프링 구조를 따옴
  + 모델
    * 비즈니스 로직과 사용되는 데이터를 다루는 영역
  + 뷰
    * 사용자에게 보여지는 화면
  + 컨트롤러
    * 모델과 뷰에 의존
    * 컨트롤러는 뷰에 데이터를 전달하고 모델을 통해 데이터를 불러오고 변경함
  + 단점
    * 액티비티 똔느 프래그먼트가 같은 컨트롤러에 작성된느 경향이 있어 코드 파악이 쉬움
    * 점진적으로 코드가 증가할 수 밖에 없고 유지보수비가 증가함
    * 의존도로 인해 유닛테스트가 힘듬

- MVP 디자인 패턴
  + View - Presenter - Model 구조로 사용자와 프레젠터의 구조를 끊음
  + 뷰와 프레젠터의 1:1 의존 관계를 유지해야하기에 재사용이 힘든점이 있음

- MVVM 디자인 패턴
  + ViewModel 과 View 의 관계를 느슨하게 만듬. 변경사항을 관찰하게 함
  + ViewModel 과 View 관계를 1:N 관계 가능해짐 (MVP 에서는 1:1 관계)


---


## CHAPTER 02 

### 1. 의존성 주입
- 의존성은 객체 지향에서 두 클래스 간의 관계로 둘 중 누군가가 다른 하나를 필요로 함
- 의존성 주입 의존 관계에 있는 클래스의 객체를 외부로부터 생성하여 주입받는 것이라 말함

### 2. 의존성 주입의 필요성
- 변경의 전이
  + Computer 가 CPU 한 가지 타입에 의존하는 경우
    * CPU가 변경되면 코드를 계속해서 수정해야 하기에 CPU를 인터페이스로 만듬
    * 다른 회사 CPU면 변경점이 또 생김

- 제어의 역전
  + Computer 클래스 내부에서 관리하는 객체를 외부에서 생성해서 전달

- 의존성 주입의 장단점
  + 장점
    * 인터페이스 기반 설계되며 코드를 유연하게 함
    * 주입하는 코드만 변경하기 쉬워 리팩토링이 수월
    * stub or mock 객체를 사용하여 단위 테스트 쉬워짐
    * 클래스 간 결합도 느슨하게 함
    * 여러 개발자가 서로 사용하는 클래스를 독립적 개발 가능
  + 단점
    * 간단한 프로그램 만들 때 번거로움
    * 동작과 구성을 분리해 코드 추적하기 어렵게 다고성 떨어뜨릴 수 있음. 개발자는 많은 파일 참조가 필요함
    * Dagger2 같은 DI 프레임워크는 컴파일 타임에 애노테이션 프로새서를 이용하여 파일 생성하므로 빌드에 시간이 조금 더 소요 됨

### 3. Dagger 2 란 무엇인가?
- 의존성 주입 프레임워크 for java and android
- 컴파일 타임에 애노테이션 프로세서에 의해 의존성 주입과 관련된 모든 코드를 분석하고 자바 소스 코드를 생성